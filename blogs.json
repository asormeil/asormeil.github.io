{"status":"ok","feed":{"url":"https://medium.com/feed/@asormeil","title":"Stories by Sormeil on Medium","link":"https://medium.com/@asormeil?source=rss-5b652f7be068------2","author":"","description":"Stories by Sormeil on Medium","image":"https://cdn-images-1.medium.com/fit/c/150/150/1*4rLd-vl3ofaWnCuQxrgVdQ.jpeg"},"items":[{"title":"Understanding and Utilizing Decorators in TypeScript: A Simple Guide","pubDate":"2023-12-28 13:54:23","link":"https://medium.com/@asormeil/understanding-and-utilizing-decorators-in-typescript-a-simple-guide-2328228aac85?source=rss-5b652f7be068------2","guid":"https://medium.com/p/2328228aac85","author":"Sormeil","thumbnail":"","description":"\n<h3>Introduction</h3>\n<p>Decorators in TypeScript are a powerful and expressive feature of the language. They provide a way to add annotations and a meta-programming syntax for class declarations and members. Decorators are a part of the ECMAScript proposal, which TypeScript adopts to provide more functionality with minimal\u00a0syntax.</p>\n<h3>What are Decorators?</h3>\n<p>A decorator is a special kind of declaration that can be attached to a class declaration, method, accessor, property, or parameter. Decorators use the form @expression, where the expression must evaluate a function that will be called at runtime with information about the decorated declaration.</p>\n<h3>Types of Decorators</h3>\n<p><strong>Class Decorators:</strong> Applied to class constructors, they can observe, modify, or replace a class definition. The following example shows a simple class decorator @Component. When the UserComponent class is defined, the decorator is\u00a0called.</p>\n<pre>function Component(constructor: Function) {<br>    console.log('Component decorator called');<br>    constructor.prototype.isComponent = true;<br>}<br><br>@Component<br>class UserComponent {<br>    constructor() {<br>        console.log('UserComponent instance created');<br>    }<br>}</pre>\n<p><strong>Method Decorators:</strong> Applied to method declarations, they can be used to observe, modify, or replace method definitions. In the following example, @Log is a method decorator that wraps the getProduct method to add logging functionality.</p>\n<pre>function Log(target: any, propertyKey: string, descriptor: PropertyDescriptor) {<br>    const originalMethod = descriptor.value;<br>    descriptor.value = function(...args: any[]) {<br>        console.log(`Method ${propertyKey} called with args: ${JSON.stringify(args)}`);<br>        return originalMethod.apply(this, args);<br>    }<br>}<br><br>class ProductService {<br>    @Log<br>    getProduct(id: number) {<br>        console.log(`Fetching product with id: ${id}`);<br>    }<br>}</pre>\n<p><strong>Property Decorators:</strong> Applied to property declarations, they provide a way to add additional metadata or logic. Here we can see that @DefaultValue decorator assigns a default value to the apiUrl property of the Configuration class.</p>\n<pre>function DefaultValue(value: string) {<br>    return function(target: any, propertyKey: string) {<br>        target[propertyKey] = value;<br>    }<br>}<br><br>class Configuration {<br>    @DefaultValue('http://my.api.com')<br>    public apiUrl: string;<br>}</pre>\n<p><strong>Parameter Decorators:</strong> Applied to parameters in class constructors. In the next example, the @Required decorator is used here to mark the message parameter in logMessage method as required.</p>\n<pre>function Required(target: any, propertyKey: string | symbol, parameterIndex: number) {<br>    console.log(`Required parameter at index ${parameterIndex} in method ${propertyKey.toString()}`);<br>}<br><br>class Logger {<br>    logMessage(@Required message: string) {<br>        console.log(message);<br>    }<br>}</pre>\n<h3>Conclusion</h3>\n<p>Decorators in TypeScript offer a declarative and elegant way to modify the behavior of classes, methods, properties, and parameters. They encourage a cleaner and more modular codebase, facilitating aspects like logging, validation, and metadata management. As TypeScript continues to evolve, decorators are likely to become an integral part of the TypeScript developer\u2019s toolkit.</p>\n<p>References:</p>\n<p><a href=\"https://www.typescriptlang.org/docs/handbook/decorators.html\"><em>https://www.typescriptlang.org/docs/handbook/decorators.html</em></a></p>\n<p><a href=\"https://refine.dev/blog/typescript-decorators/#decorating-a-class-with-typescript-decorators\"><em>https://refine.dev/blog/typescript-decorators/#decorating-a-class-with-typescript-decorators</em></a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=2328228aac85\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<h3>Introduction</h3>\n<p>Decorators in TypeScript are a powerful and expressive feature of the language. They provide a way to add annotations and a meta-programming syntax for class declarations and members. Decorators are a part of the ECMAScript proposal, which TypeScript adopts to provide more functionality with minimal\u00a0syntax.</p>\n<h3>What are Decorators?</h3>\n<p>A decorator is a special kind of declaration that can be attached to a class declaration, method, accessor, property, or parameter. Decorators use the form @expression, where the expression must evaluate a function that will be called at runtime with information about the decorated declaration.</p>\n<h3>Types of Decorators</h3>\n<p><strong>Class Decorators:</strong> Applied to class constructors, they can observe, modify, or replace a class definition. The following example shows a simple class decorator @Component. When the UserComponent class is defined, the decorator is\u00a0called.</p>\n<pre>function Component(constructor: Function) {<br>    console.log('Component decorator called');<br>    constructor.prototype.isComponent = true;<br>}<br><br>@Component<br>class UserComponent {<br>    constructor() {<br>        console.log('UserComponent instance created');<br>    }<br>}</pre>\n<p><strong>Method Decorators:</strong> Applied to method declarations, they can be used to observe, modify, or replace method definitions. In the following example, @Log is a method decorator that wraps the getProduct method to add logging functionality.</p>\n<pre>function Log(target: any, propertyKey: string, descriptor: PropertyDescriptor) {<br>    const originalMethod = descriptor.value;<br>    descriptor.value = function(...args: any[]) {<br>        console.log(`Method ${propertyKey} called with args: ${JSON.stringify(args)}`);<br>        return originalMethod.apply(this, args);<br>    }<br>}<br><br>class ProductService {<br>    @Log<br>    getProduct(id: number) {<br>        console.log(`Fetching product with id: ${id}`);<br>    }<br>}</pre>\n<p><strong>Property Decorators:</strong> Applied to property declarations, they provide a way to add additional metadata or logic. Here we can see that @DefaultValue decorator assigns a default value to the apiUrl property of the Configuration class.</p>\n<pre>function DefaultValue(value: string) {<br>    return function(target: any, propertyKey: string) {<br>        target[propertyKey] = value;<br>    }<br>}<br><br>class Configuration {<br>    @DefaultValue('http://my.api.com')<br>    public apiUrl: string;<br>}</pre>\n<p><strong>Parameter Decorators:</strong> Applied to parameters in class constructors. In the next example, the @Required decorator is used here to mark the message parameter in logMessage method as required.</p>\n<pre>function Required(target: any, propertyKey: string | symbol, parameterIndex: number) {<br>    console.log(`Required parameter at index ${parameterIndex} in method ${propertyKey.toString()}`);<br>}<br><br>class Logger {<br>    logMessage(@Required message: string) {<br>        console.log(message);<br>    }<br>}</pre>\n<h3>Conclusion</h3>\n<p>Decorators in TypeScript offer a declarative and elegant way to modify the behavior of classes, methods, properties, and parameters. They encourage a cleaner and more modular codebase, facilitating aspects like logging, validation, and metadata management. As TypeScript continues to evolve, decorators are likely to become an integral part of the TypeScript developer\u2019s toolkit.</p>\n<p>References:</p>\n<p><a href=\"https://www.typescriptlang.org/docs/handbook/decorators.html\"><em>https://www.typescriptlang.org/docs/handbook/decorators.html</em></a></p>\n<p><a href=\"https://refine.dev/blog/typescript-decorators/#decorating-a-class-with-typescript-decorators\"><em>https://refine.dev/blog/typescript-decorators/#decorating-a-class-with-typescript-decorators</em></a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=2328228aac85\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["decorators","metaprogramming","typescript"]},{"title":"Interviewer: when do you use git rebase over git merge?","pubDate":"2023-12-14 13:08:33","link":"https://medium.com/@asormeil/interviewer-have-you-ever-used-git-rebase-for-shared-branches-d9bf516307e7?source=rss-5b652f7be068------2","guid":"https://medium.com/p/d9bf516307e7","author":"Sormeil","thumbnail":"","description":"\n<p>In the world of software development, interviews often delve into the practical knowledge of tools we use every day. One such interview, which remains vivid in my memory, particularly focused on my experience with Git, specifically with the git rebase command in the context of shared branches.</p>\n<p>\u201c<strong><em>Have you ever used </em></strong><strong><em>git rebase for shared branches?</em></strong>\" the interviewer asked. This wasn't just a question about my technical skills, but a test of my understanding of best practices in version\u00a0control.</p>\n<p>At the time, I was aware that both git merge and git rebase essentially served the same purpose \u2013 to integrate changes from one branch into another. However, their outcomes and implications on the project history are markedly different. Eager to showcase my hands-on experience, I responded, \"<strong><em>I might have, but primarily for cleaning up local sources!</em></strong>\" My logic was grounded in the belief that maintaining a clean history before integrating code into the main or production branches was\u00a0crucial.</p>\n<p>Despite this, my approach did not align with the interviewer\u2019s expectations. They seemed to prefer a more traditional stance, <strong><em>particularly in maintaining a clear, chronological history of changes\u200a\u2014\u200aa practice often considered critical in open-source projects or shared repositories</em></strong>. In essence, my candid admission of \u201ccleaning the history\u201d before a merge was not received positively.</p>\n<p>What this interview taught me was invaluable: <strong><em>understanding the tools is just one part of the equation. Knowing when and how to use them, especially in a collaborative setting, is equally, if not more, important</em>.</strong> It\u2019s not just about keeping the code base clean but doing so in a way that respects the workflow and preferences of a diverse development team.</p>\n<p>This experience just like any other \"<em>we regret to inform you,\u201d </em>was a turning point for me. I dove deeper into my Git education. The risk of altering shared history, potentially creating discrepancies and confusion among team members, was a significant concern.</p>\n<p>If you\u2019re looking to dive deeper into the nuances between `git rebase` and `git merge`, I\u2019ve found a couple of resources incredibly insightful:</p>\n<p>1. <strong>Atlassian\u2019s Git Tutorials</strong>: <a href=\"https://medium.com/u/5aa6b9976187\">Atlassian</a> provides an excellent comparison of git rebase and git merge. Their guide not only contrasts these two commands but also explores potential scenarios where rebasing could seamlessly fit into your typical Git workflow. Check out their detailed explanation <a href=\"https://www.atlassian.com/git/tutorials/merging-vs-rebasing\">here</a> for a comprehensive understanding.</p>\n<p><strong>2. A Classic Stack Overflow Discussion:</strong> For a more community-driven insight, there\u2019s a legendary <a href=\"https://medium.com/u/d53dd768d047\">Stack Overflow</a> thread that\u2019s been around for over 14 years! This Q&amp;A is a goldmine of practical insights and experiences shared by developers. It\u2019s interesting to see how understanding and best practices have evolved over time. You can join the ongoing conversation and explore various perspectives right\u00a0<a href=\"https://stackoverflow.com/q/804115/17996265\">here</a>.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*CEM33v8BEF7S08BmuSx-ZQ.png\"><figcaption>Legendary Stack Overflow Discussion on Git Rebase and Git\u00a0Merge</figcaption></figure><img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=d9bf516307e7\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<p>In the world of software development, interviews often delve into the practical knowledge of tools we use every day. One such interview, which remains vivid in my memory, particularly focused on my experience with Git, specifically with the git rebase command in the context of shared branches.</p>\n<p>\u201c<strong><em>Have you ever used </em></strong><strong><em>git rebase for shared branches?</em></strong>\" the interviewer asked. This wasn't just a question about my technical skills, but a test of my understanding of best practices in version\u00a0control.</p>\n<p>At the time, I was aware that both git merge and git rebase essentially served the same purpose \u2013 to integrate changes from one branch into another. However, their outcomes and implications on the project history are markedly different. Eager to showcase my hands-on experience, I responded, \"<strong><em>I might have, but primarily for cleaning up local sources!</em></strong>\" My logic was grounded in the belief that maintaining a clean history before integrating code into the main or production branches was\u00a0crucial.</p>\n<p>Despite this, my approach did not align with the interviewer\u2019s expectations. They seemed to prefer a more traditional stance, <strong><em>particularly in maintaining a clear, chronological history of changes\u200a\u2014\u200aa practice often considered critical in open-source projects or shared repositories</em></strong>. In essence, my candid admission of \u201ccleaning the history\u201d before a merge was not received positively.</p>\n<p>What this interview taught me was invaluable: <strong><em>understanding the tools is just one part of the equation. Knowing when and how to use them, especially in a collaborative setting, is equally, if not more, important</em>.</strong> It\u2019s not just about keeping the code base clean but doing so in a way that respects the workflow and preferences of a diverse development team.</p>\n<p>This experience just like any other \"<em>we regret to inform you,\u201d </em>was a turning point for me. I dove deeper into my Git education. The risk of altering shared history, potentially creating discrepancies and confusion among team members, was a significant concern.</p>\n<p>If you\u2019re looking to dive deeper into the nuances between `git rebase` and `git merge`, I\u2019ve found a couple of resources incredibly insightful:</p>\n<p>1. <strong>Atlassian\u2019s Git Tutorials</strong>: <a href=\"https://medium.com/u/5aa6b9976187\">Atlassian</a> provides an excellent comparison of git rebase and git merge. Their guide not only contrasts these two commands but also explores potential scenarios where rebasing could seamlessly fit into your typical Git workflow. Check out their detailed explanation <a href=\"https://www.atlassian.com/git/tutorials/merging-vs-rebasing\">here</a> for a comprehensive understanding.</p>\n<p><strong>2. A Classic Stack Overflow Discussion:</strong> For a more community-driven insight, there\u2019s a legendary <a href=\"https://medium.com/u/d53dd768d047\">Stack Overflow</a> thread that\u2019s been around for over 14 years! This Q&amp;A is a goldmine of practical insights and experiences shared by developers. It\u2019s interesting to see how understanding and best practices have evolved over time. You can join the ongoing conversation and explore various perspectives right\u00a0<a href=\"https://stackoverflow.com/q/804115/17996265\">here</a>.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*CEM33v8BEF7S08BmuSx-ZQ.png\"><figcaption>Legendary Stack Overflow Discussion on Git Rebase and Git\u00a0Merge</figcaption></figure><img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=d9bf516307e7\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["interview-questions","git"]}]}